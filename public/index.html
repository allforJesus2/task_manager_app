<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="A simple task management app">
    <link rel="manifest" href="/manifest.json">
    <title>üìù TASKER</title>
</head>
	
	
	<style>
	
			body {
		font-size: 200%;
		background-color: #000;  /* Dark grey color */
		color: #fff;             /* White text color */
		margin: 0;
		padding: 0;
		height: 100vh;
		overflow: hidden;
	}
		
		#menu, #settingsMenu, #importTextDialog {
			display: none;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: #443;   /* Medium dark grey color for menu */
			min-width: 90%;
			max-width: 400px;
			box-shadow: 16px 16px 16px 0px rgba(255,255,255,0.2); /* White shadow */
			border-radius: 15px;
			padding: 20px;
			z-index: 1000;
		}
		
		#menu .menu-title, #settingsMenu .menu-title, #importTextDialog .menu-title {
			font-size: 1.2em;
			font-weight: bold;
			color: #fff;
			margin-bottom: 15px;
			padding-bottom: 10px;
			border-bottom: 1px solid #666;
			text-align: center;
		}
		
		#menu .menu-item, #settingsMenu .menu-item, #importTextDialog .menu-item {
			padding: 12px 15px;
			margin: 8px 0;
			background-color: #555;
			border-radius: 8px;
			cursor: pointer;
			transition: background-color 0.2s;
			text-align: center;
			font-size: 1.1em;
		}
		
		#menu .menu-item:hover, #settingsMenu .menu-item:hover, #importTextDialog .menu-item:hover {
			background-color: #666;
		}
		
		#menu .menu-item:active, #settingsMenu .menu-item:active, #importTextDialog .menu-item:active {
			background-color: #777;
		}
		
		#allTasks, #todayTasks, #completedTasks {

		    font-family: 'Courier New', courier, monospace;
			font-size: 1em; /* Ensure consistent font size across all sections */

			overflow-y: auto;
			line-height: 2.5em;
			color: #fff;   /* White text color for task lists */
			padding: 10px;
			margin: 0;
		}
		
			#taskLists {
		height: calc(100vh - 120px); /* Full height minus buttons and input */
		overflow-y: auto;
	}
	
	/* Mobile-specific styles */
	@media screen and (max-width: 768px) {
		body {
			font-size: 150%; /* Slightly smaller font for mobile */
		}
		
		#all, #today, #completed {
			height: calc(100vh - 140px); /* Account for mobile nav and bottom buttons */
		}
		
		.nav-buttons button, .bottom-buttons button {
			font-size: 100%;
			padding: 2% 3%;
		}
		
		button {
			font-size: 100%;
			padding: 2% 3%;
			margin: 0.5%;
		}
		
		input[type="text"], input[type="button"] {
			font-size: 100%;
			padding: 2% 3%;
			margin: 0.5%;
		}
		
		.input-container {
			padding: 5px;
			gap: 5px;
		}
	}
	
	/* Extra small mobile devices */
	@media screen and (max-width: 480px) {
		#all, #today, #completed {
			height: calc(100vh - 120px); /* Even more optimized for small screens */
		}
		
		body {
			font-size: 120%; /* Even smaller font for very small screens */
		}
		
		.nav-buttons, .bottom-buttons {
			padding: 5px;
		}
		
		.nav-buttons button, .bottom-buttons button {
			font-size: 90%;
			padding: 1% 2%;
		}
	}
	
	/* Navigation buttons container */
	.nav-buttons {
		display: flex;
		justify-content: space-around;
		padding: 10px;
		background-color: #000;
		border-bottom: 1px solid #333;
	}
	
	.nav-buttons button {
		flex: 1;
		margin: 0 5px;
	}
	
	/* Bottom buttons container */
	.bottom-buttons {
		position: fixed;
		bottom: 0;
		left: 0;
		right: 0;
		display: flex;
		justify-content: space-around;
		padding: 10px;
		background-color: #000;
		border-top: 1px solid #333;
	}
	
	.bottom-buttons button {
		flex: 1;
		margin: 0 5px;
	}
	
	/* Input container for search bar and ADD button */
	.input-container {
		display: flex;
		align-items: center;
		padding: 10px;
		gap: 10px;
	}
	
	.input-container input[type="text"] {
		flex: 1;
		margin: 0;
	}
	
	.input-container button {
		margin: 0;
		white-space: nowrap;
	}
	
	/* Ensure full height containers */
	#all, #today, #completed {
		height: calc(100vh - 120px); /* Account for top nav and bottom buttons */
		display: flex;
		flex-direction: column;
		padding-bottom: 60px; /* Space for bottom buttons */
	}
	
	#all #taskLists, #today #taskLists, #completed #taskLists {
		flex: 1;
		overflow-y: auto;
	}

		
		
		button {
			font-size: 120%;
			padding: 1% 5%;
			margin: 1%;
			border-radius: 10px;
			background-color: #333; /* Medium dark grey color */
			border: none;
			color: white; /* White text color */
		}
		
		input[type="text"], input[type="button"] {
			font-size: 120%;
			padding: 1% 5%;
			margin: 1%;
			border-radius: 10px;
			background-color: #333; /* Medium dark grey color */
			font-family: 'Courier New', courier, monospace;
			color: white; /* White text color */
		}
	
	
	.button-clicked {
		border: 1px solid yellow; /* Yellow border */
		color: white; /* White text color */
		background-color: #555; /* Medium dark grey color */
	}

	.end-day-button {
		color: #f30; /* White text color */
		background-color: #333; /* Medium dark grey color */
	}

	.close-button {
		color: #f30; /* Orange text color */
		background-color: #333; /* Medium dark grey color */
	}




	
	
	</style>
</head>
<body>
    <!-- Top Navigation Buttons -->
    <div class="nav-buttons">
        <button onclick="show('all')">ALL</button>
        <button onclick="show('today')">TODAY</button>
        <button onclick="show('completed')">COMPLETED</button>
    </div>
	
    <div id="all">
        <div class="input-container">
            <input type="text" id="taskInput" onkeydown="if (event.keyCode == 13) addTask()" placeholder="Enter new task...">
            <button onclick="addTask()">ADD</button>
        </div>
		<div id='taskLists'>
            <div id="allTasks"></div>
		</div>
    </div>

    <div id="today" style="display:none">
	    <div id='taskLists'>
            <div id="todayTasks"></div>
	    </div>
    </div>

    <div id="completed" style="display:none">
	    <div id='taskLists'>
            <div id="completedTasks"></div>
	    </div>
    </div>

    <!-- Bottom Fixed Buttons -->
    <div class="bottom-buttons">
        <button onclick="zoomIn()">ZOOM IN</button>
        <button onclick="zoomOut()">ZOOM OUT</button>
        <button class="end-day-button" onclick="endDay()">END DAY</button>
        <button onclick="showSettings(event)" id="settingsButton">SETTINGS</button>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" style="display: none;">
        <div class="menu-title">Settings</div>
        <div class="menu-item" onclick="downloadTasks()">Download Tasks</div>
        <div class="menu-item" onclick="uploadTasks()">Upload Tasks</div>
        <div class="menu-item" onclick="importFromText()">Import from Text</div>
        <div class="menu-item" onclick="clearCache()">Update App</div>
        <div class="menu-item close-button" onclick="hideSettings()">Close Menu</div>
    </div>

    <!-- Import Text Dialog -->
    <div id="importTextDialog" style="display: none;">
        <div class="menu-title">Import from Text</div>
        <div style="margin: 15px 0;">
            <textarea id="importTextArea" placeholder="Paste your tasks here, one per line..." style="width: 100%; height: 200px; background-color: #333; color: white; border: 1px solid #666; border-radius: 8px; padding: 10px; font-family: 'Courier New', courier, monospace; font-size: 0.9em; resize: vertical;"></textarea>
        </div>
        <div class="menu-item" onclick="processImportText()">Import Tasks</div>
        <div class="menu-item close-button" onclick="hideImportDialog()">Cancel</div>
    </div>

    <div id="menu"></div>


    <script>
	
        // Let CSS handle the height for better mobile responsiveness
        // Removed dynamic height setting to allow CSS media queries to work properly
		
        class Task {
            constructor(name) {
                this.name = name;
                this.status = 0;
                this.date_created = Date.now();
                this.dates_completed = [];
                this.recurring = false;
            }
        }

        let tasks = [];
        let selectedTaskIndex = null;
		
		function addTask() {
			let taskName = document.getElementById('taskInput').value;
			
			// Check if the input field is not blank
			if (taskName.trim() !== '') {
				tasks.unshift(new Task(taskName)); 
				localStorage.setItem('tasks', JSON.stringify(tasks)); 
				document.getElementById('taskInput').value = '';
				// Clear any pending search timeout
				clearTimeout(searchTimeout);
				// Update the task list with empty filter to show all tasks
				updateTaskList('').catch(console.error);
			}
		}
		
		function clearServiceWorkerData() {
		  caches.keys().then(function(names) {
			for (let name of names) caches.delete(name);
		  });
		}



        function showMenu(event, index) {
            event.stopPropagation();
            selectedTaskIndex = index;
            let menu = document.getElementById('menu');
            menu.style.display = 'block';
            menu.innerHTML = `
                <div class="menu-title">${tasks[index].name}</div>
                <div class="menu-item" onclick="renameTask()">Rename</div>
                <div class="menu-item" onclick="toggleRecurring()">Set Recurring ${tasks[index].recurring ? 'False' : 'True'}</div>
                <div class="menu-item" onclick="deleteTask()">Delete</div>
                <div class="menu-item" onclick="completeTask()">Complete</div>
                <div class="menu-item" onclick="setStatus2AndAddTask()">Check and Add New Task</div>
                <div class="menu-item close-button" onclick="hideMenu()">Close Menu</div>
            `;
        }
		
		
		function setStatus2AndAddTask() {
			tasks[selectedTaskIndex].status = 2;
			let taskName = prompt('Enter new task name');
			
						// Check if taskName is null or empty
			if (!taskName) {
				hideMenu();
				show(getCurrentSection()).catch(console.error);
				return; // Exit the function early
			}
			tasks.push(new Task(taskName));
			hideMenu();
			localStorage.setItem('tasks', JSON.stringify(tasks));
			show(getCurrentSection()).catch(console.error);
		}

        function hideMenu() {
            document.getElementById('menu').style.display = 'none';
        }

        function showSettings(event) {
            console.log('showSettings called');
            if (event) {
                event.stopPropagation(); // Prevent the click from bubbling up to window
            }
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu) {
                settingsMenu.style.display = 'block';
                console.log('Settings menu should be visible now');
            } else {
                console.error('settingsMenu element not found');
            }
        }

        function hideSettings() {
            console.log('hideSettings called');
            const settingsMenu = document.getElementById('settingsMenu');
            if (settingsMenu) {
                settingsMenu.style.display = 'none';
                console.log('Settings menu hidden');
            } else {
                console.error('settingsMenu element not found');
            }
        }

        // Zoom functionality
        let currentZoom = 100;
        const zoomStep = 10;
        const minZoom = 80;
        const maxZoom = 200;

        function zoomIn() {
            if (currentZoom < maxZoom) {
                currentZoom += zoomStep;
                applyZoom();
            }
        }

        function zoomOut() {
            if (currentZoom > minZoom) {
                currentZoom -= zoomStep;
                applyZoom();
            }
        }

        function applyZoom() {
            document.body.style.fontSize = currentZoom + '%';
            // Store zoom level in localStorage
            localStorage.setItem('zoomLevel', currentZoom);
        }

        function loadZoomLevel() {
            const savedZoom = localStorage.getItem('zoomLevel');
            if (savedZoom) {
                currentZoom = parseInt(savedZoom);
                applyZoom();
            }
        }

        function getCurrentSection() {
            const activeButton = document.querySelector('.nav-buttons button.button-clicked');
            if (activeButton) {
                const onclick = activeButton.getAttribute('onclick');
                if (onclick.includes("show('all')")) return 'all';
                if (onclick.includes("show('today')")) return 'today';
                if (onclick.includes("show('completed')")) return 'completed';
            }
            return 'all'; // default fallback
        }

        function renameTask() {
            let newName = prompt('Enter new name', tasks[selectedTaskIndex].name);
            if (newName) {
                tasks[selectedTaskIndex].name = newName;
            }
			localStorage.setItem('tasks', JSON.stringify(tasks));
            hideMenu();
            show(getCurrentSection()).catch(console.error);
        }

        function toggleRecurring() {
            tasks[selectedTaskIndex].recurring = !tasks[selectedTaskIndex].recurring;
            hideMenu();
			localStorage.setItem('tasks', JSON.stringify(tasks));
            show(getCurrentSection()).catch(console.error);
        }

        function deleteTask() {
            tasks.splice(selectedTaskIndex, 1);
            hideMenu();
			localStorage.setItem('tasks', JSON.stringify(tasks));
            show(getCurrentSection()).catch(console.error);
        }

        function completeTask() {
            tasks[selectedTaskIndex].status = 2;
            tasks[selectedTaskIndex].dates_completed.push(Date().now());
			localStorage.setItem('tasks', JSON.stringify(tasks));
            hideMenu();
            show(getCurrentSection()).catch(console.error);
        }

		// Debounced search function to prevent input field reset
		let searchTimeout;
		document.getElementById('taskInput').addEventListener('input', function() {
			// Clear previous timeout
			clearTimeout(searchTimeout);
			
			// Only search if 3 or more characters are entered or if cleared
			if (this.value.length >= 3 || this.value.length === 0) {
				// Debounce the search to prevent rapid firing
				searchTimeout = setTimeout(() => {
					// Store current input value
					const currentValue = this.value;
					
					// Only update if we're in the 'all' section
					const currentSection = getCurrentSection();
					if (currentSection === 'all') {
						updateTaskList(currentValue).catch(console.error);
					}
				}, 300); // 300ms delay
			}
		});

		// Function to update only the task list without affecting the input field
		async function updateTaskList(filterValue) {
			if (!tasks) {
				tasks = JSON.parse(localStorage.getItem('tasks')) || [];
			}
			
			let allTasksDiv = document.getElementById('allTasks');
			if (!allTasksDiv) return;
			
			// Store current focus state
			const taskInput = document.getElementById('taskInput');
			const wasFocused = document.activeElement === taskInput;
			const cursorPosition = wasFocused ? taskInput.selectionStart : 0;
			
			showLoadingIndicator('allTasks');
			
			// Filter tasks asynchronously
			const filteredTasks = [];
			await new Promise((resolve) => {
				setTimeout(() => {
					tasks.forEach((task, index) => {
						if (matchesSearch(task.name, filterValue)) {
							const isCompleted = task.dates_completed.length > 0;
							const shouldShow = filterValue.length === 0 ? 
								!(task.recurring === false && isCompleted) : 
								true;
							
							if (shouldShow) {
								filteredTasks.push({ task, index });
							}
						}
					});
					
					// Sort tasks by creation date (newest first)
					filteredTasks.sort((a, b) => b.task.date_created - a.task.date_created);
					
					resolve();
				}, 0);
			});

			// Render tasks in batches
			allTasksDiv.innerHTML = '';
			await renderTasksBatch(filteredTasks, allTasksDiv, ({ task, index }) => {
				const isCompleted = task.dates_completed.length > 0;
				const taskColor = isCompleted ? 'orange' : 'white';
				// Use the original index from the main tasks array for accurate targeting
				const originalIndex = tasks.indexOf(task);
				let taskHtml = `<input type="checkbox" onclick="toggleAll(${originalIndex})" ${task.status > 0 ? 'checked' : ''}><label style="padding-left: 15px;"><span style="color: ${taskColor};" onclick="showMenu(event, ${originalIndex})">${task.name}</span>`;
				
				// Add completion date for completed tasks
				if (isCompleted && task.dates_completed.length > 0) {
					const lastCompletedDate = new Date(task.dates_completed[task.dates_completed.length - 1]).toLocaleDateString('en-US', { 
						year: 'numeric', 
						month: 'short', 
						day: 'numeric' 
					});
					taskHtml += `<span style="color: #888; font-size: 0.7em; margin-left: 10px;">last completed: ${lastCompletedDate}</span>`;
				}
				
				taskHtml += '<br>';
				allTasksDiv.innerHTML += taskHtml;
			}, 15);
			
			// Restore focus and cursor position if it was focused before
			if (wasFocused) {
				taskInput.focus();
				taskInput.setSelectionRange(cursorPosition, cursorPosition);
			}
		}

		function matchesSearch(taskName, searchTerms) {
			if (!searchTerms || searchTerms.trim() === '') return true;
			const taskLower = taskName.toLowerCase();
			const words = searchTerms.trim().split(/\s+/);
			return words.every(word => taskLower.includes(word));
		}



	async function show(section) {
		// Store current input value to preserve it
		const taskInput = document.getElementById('taskInput');
		const currentInputValue = taskInput.value;
		
		// Remove the 'button-clicked' class from all navigation buttons
		document.querySelectorAll('.nav-buttons button').forEach(button => {
			button.classList.remove('button-clicked');
		});

		// Add the 'button-clicked' class to the clicked button
		document.querySelector(`.nav-buttons button[onclick="show('${section}')"]`).classList.add('button-clicked');

		hideMenu();
		document.getElementById('all').style.display = 'none';
		document.getElementById('today').style.display = 'none';
		document.getElementById('completed').style.display = 'none';
		
		// Restore input value after section change
		setTimeout(() => {
			taskInput.value = currentInputValue;
		}, 0);

		// Load tasks asynchronously
		const loadTasks = () => {
			return new Promise((resolve) => {
				setTimeout(() => {
					const tasksData = localStorage.getItem('tasks');
					const loadedTasks = tasksData ? JSON.parse(tasksData) : [];
					resolve(loadedTasks);
				}, 0);
			});
		};

		tasks = await loadTasks();

		if (section === 'all') {
			document.getElementById('all').style.display = 'block';
			// Use the updateTaskList function to preserve input field
			await updateTaskList(document.getElementById('taskInput').value.toLowerCase());

		} else if (section === 'today') {
			let todayTasksDiv = document.getElementById('todayTasks');
			showLoadingIndicator('todayTasks');
			document.getElementById('today').style.display = 'block';

			const todayTasks = tasks.filter((task, index) => task.status > 0);
			
			// Sort today tasks by creation date (newest first)
			todayTasks.sort((a, b) => b.date_created - a.date_created);
			
			todayTasksDiv.innerHTML = '';
			await renderTasksBatch(todayTasks, todayTasksDiv, (task, index) => {
				// Find the original index of the task in the main tasks array
				const originalIndex = tasks.findIndex(t => t === task);
				todayTasksDiv.innerHTML += `<input type="checkbox" onclick="toggleToday(${originalIndex})" ${task.status === 2 ? 'checked' : ''}><label style="padding-left: 15px;"><span onclick="showMenu(event, ${originalIndex})">${task.name}</span><br>`;
			}, 20);

		} else if (section === 'completed') {
			let completedTasksDiv = document.getElementById('completedTasks');
			showLoadingIndicator('completedTasks');
			document.getElementById('completed').style.display = 'block';

			const completedTasks = [];
			tasks.forEach((task) => {
				if (task.dates_completed.length > 0) {
					task.dates_completed.forEach(date => {
						completedTasks.push({ task, date });
					});
				}
			});

			completedTasksDiv.innerHTML = '';
			await renderTasksBatch(completedTasks, completedTasksDiv, ({ task, date }) => {
				let formattedDate = new Date(date).toLocaleString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
				completedTasksDiv.innerHTML += `<span>${formattedDate} </span><span style="color: orange;">${task.name} </span><br>`;
			}, 25);
		}
	}


		// Call show function on page load to display existing tasks
		window.onload = function() {
			loadZoomLevel(); // Load saved zoom level
			show('all').catch(console.error);
			
			// Add backup event listener for settings button
			const settingsButton = document.getElementById('settingsButton');
			if (settingsButton) {
				settingsButton.addEventListener('click', function(event) {
					console.log('Settings button clicked via event listener');
					showSettings(event);
				});
			}
			
			// Test if showSettings function is accessible
			console.log('showSettings function available:', typeof showSettings);
		}

        function toggleAll(index) {
            tasks[index].status = tasks[index].status > 0 ? 0 : 1;
			localStorage.setItem('tasks', JSON.stringify(tasks)); // Save tasks to localStorage

            // Update only the checkbox state without re-rendering the entire list
            // Find the checkbox that was clicked by finding the one with the matching onclick attribute
            const checkboxes = document.querySelectorAll('#allTasks input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.getAttribute('onclick') === `toggleAll(${index})`) {
                    checkbox.checked = tasks[index].status > 0;
                }
            });
        }

        function toggleToday(index) {
            tasks[index].status = tasks[index].status === 2 ? 1 : 2;
			localStorage.setItem('tasks', JSON.stringify(tasks)); // Save tasks to localStorage

            // Update only the checkbox state without re-rendering the entire list
            // Find the checkbox that was clicked by finding the one with the matching onclick attribute
            const checkboxes = document.querySelectorAll('#todayTasks input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.getAttribute('onclick') === `toggleToday(${index})`) {
                    checkbox.checked = tasks[index].status === 2;
                }
            });
        }

        function endDay() {
            // Check if we're currently in the today section
            const currentSection = getCurrentSection();
            
            if (currentSection !== 'today') {
                // If not in today section, navigate to it first
                show('today').catch(console.error);
            } else {
                // If already in today section, show the confirmation dialog
                if (confirm('Are you sure you want to end the day?')) {
                    tasks.forEach((task) => {
                        if (task.status === 2) {
                            task.dates_completed.push(Date.now());
                        }
                        task.status = 0;
                    });
                    localStorage.setItem('tasks', JSON.stringify(tasks));
                    show('today').catch(console.error);
                }
            }
        }
		
		
		function downloadTasks() {
			let json = JSON.stringify(tasks);
			let a = document.createElement("a");
			a.href = URL.createObjectURL(new Blob([json], {type: 'application/json'}));
			a.download = "tasks.json";
			a.click();
		}

		function uploadTasks() {
			let input = document.createElement('input');
			input.type = 'file';
			input.onchange = (e) => {
				let file = e.target.files[0];
				let reader = new FileReader();
				reader.onload = () => {
					tasks = JSON.parse(reader.result);
					localStorage.setItem('tasks', JSON.stringify(tasks)); // Store the uploaded tasks in localStorage
					show('all').catch(console.error); // Refresh the page with the uploaded tasks
				 }
				reader.readAsText(file);
			 };
			input.click();
		}


        		function clearCache() {
            const message = "Clear cache to check for app updates and override the service worker? This will reload the page to get the latest version.";
            if (confirm(message)) {
                if ('caches' in window) {
                    caches.keys().then(function(cacheNames) {
                        return Promise.all(
                            cacheNames.map(function(cacheName) {
                                return caches.delete(cacheName);
                            })
                        );
                    }).then(function() {
                        console.log('Caches cleared');
                        alert('Cache cleared successfully. Reloading page to get the latest version.');
                        window.location.reload(true);
                    }).catch(function(error) {
                        console.error('Error clearing cache:', error);
                        alert('Error clearing cache. Please try again.');
                    });
                } else {
                    console.log('Cache API not supported');
                    alert('Cache clearing not supported in this browser.');
                }
            }
        }

		function importFromText() {
			hideSettings();
			document.getElementById('importTextDialog').style.display = 'block';
			document.getElementById('importTextArea').focus();
		}

		function hideImportDialog() {
			document.getElementById('importTextDialog').style.display = 'none';
			document.getElementById('importTextArea').value = '';
		}

		function processImportText() {
			const textArea = document.getElementById('importTextArea');
			const text = textArea.value.trim();
			
			if (!text) {
				alert('Please enter some text to import.');
				return;
			}
			
			// Split by newlines and filter out empty lines
			const lines = text.split('\n').filter(line => line.trim() !== '');
			
			if (lines.length === 0) {
				alert('No valid tasks found. Please enter at least one non-empty line.');
				return;
			}
			
			// Create new tasks from each line
			let newTasksCount = 0;
			lines.forEach(line => {
				const trimmedLine = line.trim();
				if (trimmedLine !== '') {
					tasks.unshift(new Task(trimmedLine));
					newTasksCount++;
				}
			});
			
			// Save to localStorage
			localStorage.setItem('tasks', JSON.stringify(tasks));
			
			// Close dialog and refresh
			hideImportDialog();
			show(getCurrentSection()).catch(console.error);
			
			// Show success message
			alert(`Successfully imported ${newTasksCount} task${newTasksCount !== 1 ? 's' : ''}!`);
		}


        		window.onclick = function(event) {
        			// Hide all menus when clicking outside
        			//hideMenu();
        			//hideSettings();
        			//hideImportDialog();
        		};
		
		// Add loading indicator styles
		const loadingStyles = document.createElement('style');
		loadingStyles.textContent = `
			.loading-indicator {
				display: flex;
				justify-content: center;
				align-items: center;
				padding: 20px;
				color: #fff;
				font-size: 1.2em;
			}
			.loading-spinner {
				width: 20px;
				height: 20px;
				border: 2px solid #333;
				border-top: 2px solid #fff;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-right: 10px;
			}
			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
		`;
		document.head.appendChild(loadingStyles);

		function showLoadingIndicator(containerId) {
			const container = document.getElementById(containerId);
			container.innerHTML = '<div class="loading-indicator"><div class="loading-spinner"></div>Loading tasks...</div>';
		}

		function renderTasksBatch(tasks, container, renderFunction, batchSize = 10) {
			return new Promise((resolve) => {
				let index = 0;
				
				function processBatch() {
					const endIndex = Math.min(index + batchSize, tasks.length);
					
					for (let i = index; i < endIndex; i++) {
						renderFunction(tasks[i], i);
					}
					
					index = endIndex;
					
					if (index < tasks.length) {
						// Use requestAnimationFrame for smooth rendering
						requestAnimationFrame(processBatch);
					} else {
						resolve();
					}
				}
				
				requestAnimationFrame(processBatch);
			});
		}
		
		// Service Worker Registration
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', function() {
				navigator.serviceWorker.register('/sw.js')
					.then(function(registration) {
						console.log('ServiceWorker registration successful with scope: ', registration.scope);
						
						// Check for updates
						registration.addEventListener('updatefound', function() {
							const newWorker = registration.installing;
							newWorker.addEventListener('statechange', function() {
								if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
									console.log('New service worker available');
									// Optionally notify user about update
									if (confirm('A new version of the app is available. Would you like to update?')) {
										newWorker.postMessage({ type: 'SKIP_WAITING' });
										window.location.reload();
									}
								}
							});
						});
						
						// Handle service worker updates
						navigator.serviceWorker.addEventListener('controllerchange', function() {
							console.log('Service worker updated');
						});
					})
					.catch(function(err) {
						console.log('ServiceWorker registration failed: ', err);
					});
			});
		}
		
		// Check if app is running offline
		window.addEventListener('online', function() {
			console.log('App is online');
		});
		
		window.addEventListener('offline', function() {
			console.log('App is offline');
		});
    </script>
</body>
</html>
